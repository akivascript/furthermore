;; Analyzed by ClojureScript 0.0-3119
{:use-macros {assert-iae plumbing.fnk.schema}, :excludes #{}, :macros {assert-iae {:ns plumbing.fnk.schema, :name plumbing.fnk.schema/assert-iae, :file "plumbing/fnk/schema.clj", :column 1, :line 33, :macro true, :arglists ([form & format-args]), :doc "Like assert, but throws a RuntimeException in Clojure (not an AssertionError),\n   and also takes args to format."}}, :name plumbing.fnk.schema, :imports nil, :requires {schema-utils schema.utils, schema.utils schema.utils, schema.core schema.core, s schema.core}, :uses nil, :defs {required-toplevel-keys {:schema (schema.core/make-fn-schema output-schema17918 [input-schema17919]), :protocol-inline nil, :meta {:arglists (quote ([input-schema])), :schema (schema.core/make-fn-schema output-schema17918 [input-schema17919]), :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs", :line 141, :column 9, :end-line 141, :end-column 31, :doc "Inputs: [input-schema :- InputSchema]\n  Returns: [s/Keyword]\n\n  Which top-level keys are required (i.e., non-false) by this input schema.", :raw-arglists (quote ([input-schema :- InputSchema]))}, :name plumbing.fnk.schema/required-toplevel-keys, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 31, :method-params ([G__17922]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :raw-arglists (quote ([input-schema :- InputSchema])), :line 141, :end-line 141, :max-fixed-arity 1, :fn-var true, :arglists (quote ([input-schema])), :doc "Inputs: [input-schema :- InputSchema]\n  Returns: [s/Keyword]\n\n  Which top-level keys are required (i.e., non-false) by this input schema.", :test true}, InputSchema {:meta {:end-column 17, :end-line 23, :column 6, :line 23, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :line 23, :column 1, :end-line 23, :end-column 17, :test true, :name plumbing.fnk.schema/InputSchema}, possibly-contains? {:protocol-inline nil, :meta {:arglists (quote ([m k])), :end-column 25, :end-line 217, :column 7, :line 217, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :name plumbing.fnk.schema/possibly-contains?, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 25, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 217, :end-line 217, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k])), :test true}, schema-key {:protocol-inline nil, :meta {:arglists (quote ([m k])), :end-column 17, :end-line 208, :column 7, :line 208, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :name plumbing.fnk.schema/schema-key, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 17, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil schema.core/OptionalKey clj-nil}, :variadic false, :max-fixed-arity 2}), :line 208, :end-line 208, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k])), :test true}, map-schema? {:protocol-inline nil, :meta {:arglists (quote ([m])), :end-column 18, :end-line 74, :column 7, :line 74, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :name plumbing.fnk.schema/map-schema?, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 18, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 74, :end-line 74, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :test true}, MapOutputSchema {:meta {:end-column 21, :end-line 28, :column 6, :line 28, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :line 28, :column 1, :end-line 28, :end-column 21, :test true, :name plumbing.fnk.schema/MapOutputSchema}, unwrap-schema-form-key {:schema (schema.core/make-fn-schema output-schema17848 [input-schema17849]), :protocol-inline nil, :meta {:arglists (quote ([k])), :schema (schema.core/make-fn-schema output-schema17848 [input-schema17849]), :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs", :line 81, :column 9, :end-line 81, :end-column 31, :doc "Inputs: [k]\n  Returns: (s/maybe (s/pair s/Keyword \"k\" s/Bool \"optional?\"))\n\n  Given a possibly-unevaluated schema map key form, unpack an explicit keyword\n   and optional? flag, or return nil for a non-explicit key", :raw-arglists (quote ([k]))}, :name plumbing.fnk.schema/unwrap-schema-form-key, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 31, :method-params ([G__17852]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/IVector clj-nil}, :variadic false, :max-fixed-arity 1}), :raw-arglists (quote ([k])), :line 81, :end-line 81, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :doc "Inputs: [k]\n  Returns: (s/maybe (s/pair s/Keyword \"k\" s/Bool \"optional?\"))\n\n  Given a possibly-unevaluated schema map key form, unpack an explicit keyword\n   and optional? flag, or return nil for a non-explicit key", :test true}, non-map-union {:protocol-inline nil, :meta {:arglists (quote ([s1 s2])), :end-column 20, :end-line 62, :column 7, :line 62, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :name plumbing.fnk.schema/non-map-union, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 20, :method-params ([s1 s2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil schema.core/Both}, :variadic false, :max-fixed-arity 2}), :line 62, :end-line 62, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s1 s2])), :test true}, split-schema-keys {:schema (schema.core/make-fn-schema output-schema17878 [input-schema17879]), :protocol-inline nil, :meta {:arglists (quote ([s])), :schema (schema.core/make-fn-schema output-schema17878 [input-schema17879]), :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs", :line 102, :column 9, :end-line 102, :end-column 26, :doc "Inputs: [s :- {s/Keyword s/Bool}]\n  Returns: [(s/one [s/Keyword] (quote required)) (s/one [s/Keyword] (quote optional))]\n\n  Given output of explicit-schema-key-map, split into seq [req opt].", :raw-arglists (quote ([s :- {s/Keyword s/Bool}]))}, :name plumbing.fnk.schema/split-schema-keys, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 26, :method-params ([G__17882]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :raw-arglists (quote ([s :- {s/Keyword s/Bool}])), :line 102, :end-line 102, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Inputs: [s :- {s/Keyword s/Bool}]\n  Returns: [(s/one [s/Keyword] (quote required)) (s/one [s/Keyword] (quote optional))]\n\n  Given output of explicit-schema-key-map, split into seq [req opt].", :test true}, explicit-schema-key-map {:schema (schema.core/make-fn-schema output-schema17863 [input-schema17864]), :protocol-inline nil, :meta {:arglists (quote ([s])), :schema (schema.core/make-fn-schema output-schema17863 [input-schema17864]), :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs", :line 93, :column 9, :end-line 93, :end-column 32, :doc "Inputs: [s]\n  Returns: {s/Keyword s/Bool}\n\n  Given a possibly-unevaluated map schema, return a map from bare keyword to true\n   (for required) or false (for optional)", :raw-arglists (quote ([s]))}, :name plumbing.fnk.schema/explicit-schema-key-map, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 32, :method-params ([G__17867]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 1}), :raw-arglists (quote ([s])), :line 93, :end-line 93, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Inputs: [s]\n  Returns: {s/Keyword s/Bool}\n\n  Given a possibly-unevaluated map schema, return a map from bare keyword to true\n   (for required) or false (for optional)", :test true}, schema-diff {:protocol-inline nil, :meta {:arglists (quote ([input-schema output-schema])), :doc "Subtract output-schema from input-schema, returning nil if it's possible that an object\n   satisfying the output-schema satisfies the input-schema, or otherwise a description\n   of the part(s) of input-schema not met by output-schema.  Strict about the map structure\n   of output-schema matching input-schema, but loose about everything else (only looks at\n   required keys of output-schema.", :end-column 18, :end-line 166, :column 7, :line 166, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :name plumbing.fnk.schema/schema-diff, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 18, :method-params ([input-schema output-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil schema.utils/ErrorContainer clj-nil}, :variadic false, :max-fixed-arity 2}), :line 166, :end-line 166, :max-fixed-arity 2, :fn-var true, :arglists (quote ([input-schema output-schema])), :doc "Subtract output-schema from input-schema, returning nil if it's possible that an object\n   satisfying the output-schema satisfies the input-schema, or otherwise a description\n   of the part(s) of input-schema not met by output-schema.  Strict about the map structure\n   of output-schema matching input-schema, but loose about everything else (only looks at\n   required keys of output-schema.", :test true}, non-map-diff {:protocol-inline nil, :meta {:arglists (quote ([s1 s2])), :doc "Return a difference of schmas s1 and s2, where one is not a map.\n   Punt for now, assuming s2 always satisfies s1.", :end-column 19, :end-line 68, :column 7, :line 68, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :name plumbing.fnk.schema/non-map-diff, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 19, :method-params ([s1 s2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 2}), :line 68, :end-line 68, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s1 s2])), :doc "Return a difference of schmas s1 and s2, where one is not a map.\n   Punt for now, assuming s2 always satisfies s1.", :test true}, guess-expr-output-schema {:protocol-inline nil, :meta {:arglists (quote ([expr])), :doc "Guess an output schema for an expr.  Currently just looks for literal map structure and\n   all keyword keys.", :end-column 31, :end-line 155, :column 7, :line 155, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :name plumbing.fnk.schema/guess-expr-output-schema, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 31, :method-params ([expr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/Symbol cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 1}), :line 155, :end-line 155, :max-fixed-arity 1, :fn-var true, :arglists (quote ([expr])), :doc "Guess an output schema for an expr.  Currently just looks for literal map structure and\n   all keyword keys.", :test true}, compose-schemata {:schema (schema.core/make-fn-schema output-schema17973 [input-schema17974]), :protocol-inline nil, :meta {:schema (schema.core/make-fn-schema output-schema17973 [input-schema17974]), :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 43, :column 27, :raw-arglists (quote ([[i2 o2] :- IOSchemata [i1 o1] :- [(s/one InputSchema (quote input)) (s/one MapOutputSchema (quote output))]])), :line 198, :end-line 198, :arglists (quote ([[i2 o2] [i1 o1]])), :doc "Inputs: [[i2 o2] :- IOSchemata [i1 o1] :- [(s/one InputSchema (quote input)) (s/one MapOutputSchema (quote output))]]\n\n  Given pairs of input and output schemata for fnks f1 and f2,\n   return a pair of input and output schemata for #(f2 (merge % (f1 %))).\n   f1's output schema must not contain any optional keys.", :always-validate true}, :name plumbing.fnk.schema/compose-schemata, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 43, :method-params ([G__17977 G__17978]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 2}), :raw-arglists (quote ([[i2 o2] :- IOSchemata [i1 o1] :- [(s/one InputSchema (quote input)) (s/one MapOutputSchema (quote output))]])), :line 198, :end-line 198, :max-fixed-arity 2, :fn-var true, :arglists (quote ([[i2 o2] [i1 o1]])), :doc "Inputs: [[i2 o2] :- IOSchemata [i1 o1] :- [(s/one InputSchema (quote input)) (s/one MapOutputSchema (quote output))]]\n\n  Given pairs of input and output schemata for fnks f1 and f2,\n   return a pair of input and output schemata for #(f2 (merge % (f1 %))).\n   f1's output schema must not contain any optional keys.", :test true, :always-validate true}, assert-satisfies-schema {:protocol-inline nil, :meta {:arglists (quote ([input-schema output-schema])), :end-column 30, :end-line 194, :column 7, :line 194, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :name plumbing.fnk.schema/assert-satisfies-schema, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 30, :method-params ([input-schema output-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 2}), :line 194, :end-line 194, :max-fixed-arity 2, :fn-var true, :arglists (quote ([input-schema output-schema])), :test true}, split-schema {:schema (schema.core/make-fn-schema output-schema18005 [input-schema18006]), :protocol-inline nil, :meta {:arglists (quote ([s ks])), :schema (schema.core/make-fn-schema output-schema18005 [input-schema18006]), :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs", :line 220, :column 9, :end-line 220, :end-column 21, :doc "Inputs: [s :- InputSchema ks :- [s/Keyword]]\n\n  Return a pair [ks-part non-ks-part], with any extra schema removed.", :raw-arglists (quote ([s :- InputSchema ks :- [s/Keyword]]))}, :name plumbing.fnk.schema/split-schema, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 21, :method-params ([G__18009 G__18010]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :raw-arglists (quote ([s :- InputSchema ks :- [s/Keyword]])), :line 220, :end-line 220, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s ks])), :doc "Inputs: [s :- InputSchema ks :- [s/Keyword]]\n\n  Return a pair [ks-part non-ks-part], with any extra schema removed.", :test true}, assert-distinct {:protocol-inline nil, :meta {:arglists (quote ([things])), :doc "Like (assert (distinct? things)) but with a more helpful error message.", :end-column 22, :end-line 39, :column 7, :line 39, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :name plumbing.fnk.schema/assert-distinct, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 22, :method-params ([things]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 1}), :line 39, :end-line 39, :max-fixed-arity 1, :fn-var true, :arglists (quote ([things])), :doc "Like (assert (distinct? things)) but with a more helpful error message.", :test true}, OutputSchema {:meta {:end-column 18, :end-line 24, :column 6, :line 24, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :line 24, :column 1, :end-line 24, :end-column 18, :test true, :name plumbing.fnk.schema/OutputSchema}, GraphInputSchema {:meta {:end-column 22, :end-line 27, :column 6, :line 27, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :line 27, :column 1, :end-line 27, :end-column 22, :test true, :name plumbing.fnk.schema/GraphInputSchema}, GraphIOSchemata {:meta {:end-column 21, :end-line 29, :column 6, :line 29, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :line 29, :column 1, :end-line 29, :end-column 21, :test true, :name plumbing.fnk.schema/GraphIOSchemata}, merge-on-with {:protocol-inline nil, :meta {:arglists (quote ([key-project key-combine val-combine & maps])), :doc "Like merge-with, but also projects keys to a smaller space and merges them similar to the\n   values.", :private true, :end-column 21, :end-line 109, :column 8, :line 109, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :private true, :name plumbing.fnk.schema/merge-on-with, :variadic true, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 21, :method-params ([key-project key-combine val-combine maps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic true, :max-fixed-arity 3}), :line 109, :end-line 109, :max-fixed-arity 3, :fn-var true, :arglists (quote ([key-project key-combine val-combine & maps])), :doc "Like merge-with, but also projects keys to a smaller space and merges them similar to the\n   values.", :test true}, Schema {:meta {:end-column 12, :end-line 22, :column 6, :line 22, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :line 22, :column 1, :end-line 22, :end-column 12, :test true, :name plumbing.fnk.schema/Schema}, IOSchemata {:meta {:end-column 16, :end-line 25, :column 6, :line 25, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :line 25, :column 1, :end-line 25, :end-column 16, :test true, :name plumbing.fnk.schema/IOSchemata}, union-input-schemata {:schema (schema.core/make-fn-schema output-schema17902 [input-schema17903]), :protocol-inline nil, :meta {:arglists (quote ([i1 i2])), :schema (schema.core/make-fn-schema output-schema17902 [input-schema17903]), :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs", :line 124, :column 9, :end-line 124, :end-column 29, :doc "Inputs: [i1 :- InputSchema i2 :- InputSchema]\n  Returns: InputSchema\n\n  Returns a minimal input schema schema that entails satisfaction of both s1 and s2", :raw-arglists (quote ([i1 :- InputSchema i2 :- InputSchema]))}, :name plumbing.fnk.schema/union-input-schemata, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 29, :method-params ([G__17906 G__17907]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2}), :raw-arglists (quote ([i1 :- InputSchema i2 :- InputSchema])), :line 124, :end-line 124, :max-fixed-arity 2, :fn-var true, :arglists (quote ([i1 i2])), :doc "Inputs: [i1 :- InputSchema i2 :- InputSchema]\n  Returns: InputSchema\n\n  Returns a minimal input schema schema that entails satisfaction of both s1 and s2", :test true}, sequence-schemata {:schema (schema.core/make-fn-schema output-schema18100 [input-schema18101]), :protocol-inline nil, :meta {:arglists (quote ([[i1 o1] [k [i2 o2]]])), :schema (schema.core/make-fn-schema output-schema18100 [input-schema18101]), :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs", :line 230, :column 9, :end-line 230, :end-column 26, :doc "Inputs: [[i1 o1] :- GraphIOSchemata [k [i2 o2]] :- [(s/one s/Keyword \"key\") (s/one IOSchemata \"inner-schemas\")]]\n  Returns: GraphIOSchemata\n\n  Given pairs of input and output schemata for fnks f1 and f2, and a keyword k,\n   return a pair of input and output schemata for #(let [v1 (f1 %)] (assoc v1 k (f2 (merge-disjoint % v1))))", :raw-arglists (quote ([[i1 o1] :- GraphIOSchemata [k [i2 o2]] :- [(s/one s/Keyword "key") (s/one IOSchemata "inner-schemas")]]))}, :name plumbing.fnk.schema/sequence-schemata, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 26, :method-params ([G__18104 G__18105]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 2}), :raw-arglists (quote ([[i1 o1] :- GraphIOSchemata [k [i2 o2]] :- [(s/one s/Keyword "key") (s/one IOSchemata "inner-schemas")]])), :line 230, :end-line 230, :max-fixed-arity 2, :fn-var true, :arglists (quote ([[i1 o1] [k [i2 o2]]])), :doc "Inputs: [[i1 o1] :- GraphIOSchemata [k [i2 o2]] :- [(s/one s/Keyword \"key\") (s/one IOSchemata \"inner-schemas\")]]\n  Returns: GraphIOSchemata\n\n  Given pairs of input and output schemata for fnks f1 and f2, and a keyword k,\n   return a pair of input and output schemata for #(let [v1 (f1 %)] (assoc v1 k (f2 (merge-disjoint % v1))))", :test true}, safe-get {:protocol-inline nil, :meta {:arglists (quote ([m k key-path])), :doc "Like (get m k), but throws if k is not present in m.", :end-column 15, :end-line 48, :column 7, :line 48, :file "/Users/akiva/Code/projects/furthermore/resources/public/js/out/plumbing/fnk/schema.cljs"}, :name plumbing.fnk.schema/safe-get, :variadic false, :file "resources/public/js/out/plumbing/fnk/schema.cljs", :end-column 15, :method-params ([m k key-path]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 3}), :line 48, :end-line 48, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k key-path])), :doc "Like (get m k), but throws if k is not present in m.", :test true}}, :require-macros {s schema.core, schema.core schema.core, plumbing.fnk.schema plumbing.fnk.schema, schema.macros schema.macros, schema-macros schema.macros}, :cljs.analyzer/constants {:order [:proto-sym :proto-pred :error :key :map :missing-key :else :value :schema :type :schema.core/error :extra :failures :does-not-satisfy-schema], :seen #{:schema :schema.core/error :key :else :does-not-satisfy-schema :value :proto-sym :extra :type :error :missing-key :failures :proto-pred :map}}, :doc "A very simple type system for a subset of schemas consisting of nested\n   maps with optional or required keyword keys; used by fnk and kin.\n\n   Since schemas are turing-complete and not really designed for type inference,\n   (and for simplicity) we err on the side of completeness (allowing all legal programs)\n   at the cost of soundness.\n\n   These operations also bake in some logic specific to reasoning about Graphs,\n   namely that all input keys to a node must be explicitly mentioned as optional or\n   required, or provided via `instance`, and will thus deliberately drop extra key\n   schemas on inputs as appropriate.  Output schemas may not have optional keys."}